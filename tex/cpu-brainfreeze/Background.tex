\section{Background}
    \subsection{Non-blocking Caches}
%        Caches in modern MPSoCs are a crucial component that efficiently bridges the gap between the speed of the execution units and the main memory.
%        However, as good as they are at providing high bandwidth, \emph{blocking caches} are ineffective at hiding cache-miss penaty because they stall the execution units until the data is received from the main memory.
%        In order to hide this penalty and improve the cache performance, \cite{Kroft} proposed the first \emph{Miss-Handling-Architecture} (MHA).
%        This type of cache referred to as \emph{Non-blocking} relies on the introduction of a set of new registers called \emph{Miss Status Holding Register} (MSHR), which are in charge of tracking the status of cache line misses.
%        Each MSHR stores important information regarding the cache-miss such as the target address and the location of the cache line to refill.
%        For each level of cache in a system, the amount of MSHRs denotes the number of outstanding (i.e. simultaneous) transactions it can handle.
%        %This amount is known as the \emph{Memory-Level-Parallelism} (MLP).
%
%        At run time, a non-blocking cache behaves as follows. When a cache-miss occurs, the metadata of the cache-miss is stored in one of the available MSHRs. In case the same cache-miss already occurred and one MSHR already holds the metadata, the two requests are merged.
%        It is only once the cache line refill request has been served and placed in the proper cache line that the MSHR is made available to store new cache-misses requests.
%        Provided that all the MSHRs are used at a given instant, the system stops until one of them becomes available.

        Caches in modern MPSoCs are a crucial component that efficiently bridges the gap between the speed of the execution units and the main memory.
        However, as good as they are at providing high bandwidth, \emph{blocking caches} are ineffective at hiding cache-miss penalty because they stall the execution units until the data is received from the main memory.
        In order to hide this penalty and improve the cache performance, \cite{Kroft} proposed the first \emph{Miss-Handling-Architecture} (MHA).
        This type of cache referred to as \emph{Non-blocking} relies on the introduction of a set of new registers called \emph{Miss Status Holding Register} (MSHR), which are in charge of tracking the status of cache line misses.
        Each MSHR stores important information regarding the cache-miss such as the target address and the location of the cache line to refill.
        For each level of cache in a system, the amount of MSHRs denotes the number of outstanding (i.e. simultaneous) transactions it can handle.
        %This amount is known as the \emph{Memory-Level-Parallelism} (MLP).

        At run time, a non-blocking cache behaves as follows. When a cache-miss occurs, the metadata of the cache-miss is stored in one of the available MSHRs. In case the same cache-miss already happened and one MSHR already holds the metadata, the two requests are merged.
        It is only once the cache line refill request has been served and placed in the proper cache line that the MSHR is made available to store new cache-misses requests.
        If all the MSHRs are used, the system stops until one of them becomes available.

    \subsection{Programmable Logic In the Middle (PLIM)}
%        The \emph{Programmable Logic In the Middle} (PLIM) is a new paradigm introduced by \cite{PLIM20} that takes advantage of the newly available platforms associating a traditional \emph{Processing System} (PS side) with a tightly integrated Programmable Logic (PL side).
%        In a system using PLIM, the PL side is leveraged such that the latter is located in between the core cluster and the main memory in the data path.
%        In other words, a PLIM module is a piece of custom logic located on the PL side that is capable of manipulating the transactions coming from the core cluster before they reach the main memory.
%        For instance, \cite{PLIM20} tackled important constraints imposed by the cache coloring technique by using a PLIM module (called \emph{bleacher}) by applying a configurable transformation on each incoming transaction address.
%        The use of a PLIM module broadens considerably the control over memory operations as it becomes possible to manipulate the memory traffic generated by the core cluster at the granularity of individual transactions.

        The \emph{Programmable Logic In the Middle} (PLIM) is a new paradigm introduced by \cite{PLIM20} that takes advantage of the newly available platforms associating a traditional \emph{Processing System} (PS side) with a tightly integrated Programmable Logic (PL side).
        In a PLIM system, the PL side is located in the middle of the data path, between the core cluster and the main memory.
        In other words, a PLIM module is a piece of custom logic located on the PL side that is capable of manipulating the transactions coming from the core cluster before they reach the main memory.
        For instance, \cite{PLIM20} tackles significant constraints imposed by the cache coloring technique by using a PLIM module (called \emph{bleacher}) by applying a configurable transformation on each incoming transaction address.
        Using a PLIM module broadens the control over memory operations considerably as it becomes possible to manipulate the memory traffic generated by the core cluster at the granularity of individual transactions.
