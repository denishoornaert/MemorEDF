\section{Background}
    \subsection{Non-blocking Caches}
        Caches in modern MPSoC are an angular component that efficiently bridges the gap between the speed of the excution units and  the main memory.
        However, as good as they are at proving great bandwidth, \emph{blocking caches} suffers tremendously from the cache-miss penalty as they prevent the execution units to run as long as the data is not received from the main memory.
        In order to hide this penalty and improve the cache performance, \cite{Kroft} is the first to propose a \emph{Miss-Handling-Architecture} (MHA).
        This type of cache referred to as \emph{Non-blocking} relies on the introduction of a set of new registers called \emph{Miss Status Holding Register} (MSHR), which are in charge of tracking the status of cache line miss.
        Each MSHR stores inportant information regarding the cache-miss such as the target address and the location of the cache line to refill.
        For each level of cache in a system, the amount of MSHRs denotes the amount of outstanding (i.e. simultaneous) transactions the cache can handle.
        This amount is known as the \emph{Memory-Level-Parallelism} (MLP).

        At run time, a non-blocking cache behaves as follows. When a cache-miss occur, the metadata of the cache-miss is stored in one available MSHR (\emph{primary} request). In case the same cache-miss already occured and one MSHR already holds the metadata, the two requests are merged (\emph{secondary} request). It is only once the cache line refill request as been served and placed in the proper cache line that the MSHR is made available. Provided that all the MSHRs are used at a given instant, the system stops until one of them becomes available.

    \subsection{Programmable Logic In the Middle (PLIM)}
        The \emph{Programmable Logic In the Middle} (PLIM) is a new paradigm introduce by \cite{PLIM20} that takes advantage of the newly available platforms associating a traditional \emph{Processing System} (or PL side) and a tightly integrated peice of Programmable Logic (or PL side).
        In a system using PLIM, the PL side is leveraged such that the latter is located in between the core cluster and the main memory in the data path.
        In other words, a PLIM module is a peice if custom logic located on the PL side that is capable of manipulating the transaction comming from the core cluster before forwarding them to the main memory.
        For instance, \cite{PLIM20} tackled important constraints imposed by the cache coloring technique by using a PLIM module (called \emph{bleacher}) that manipulating each incomming transaction address.
        The use of a PLIM module broadens considerably the control on the traffic and the range of possibilities as it becomes possibe to manipulate the memory traffic generated by the core cluster at the granularity of a transaction.
