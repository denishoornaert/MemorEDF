
/*********************************************************************/
/*                 TRANSFER MEMORY TO ZYNQ PL (MM2S)                 */
/*                 AND FROM ZYNQ PL TO MEMORY (S2MM)                 */
/*                                                                   */
/*            THIS C-CODE IS AUTOGENERATED BY gen-c.xslt             */
/*      COMPILE: gcc -Wall -o zynq-axi-dma-sg zynq-axi-dma-sg.c      */
/*             RUN as sudo: taskset -1 ./zynq-axi-dma-sg             */
/*********************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <time.h>
#include <sys/time.h>


/* 
        
from AXI DMA v7.1 - LogiCORE IP Product Guide http://www.xilinx.com/support/documentation/ip_documentation/axi_dma/v7_1/pg021_axi_dma.pdf

1. Write the address of the starting descriptor to the Current Descriptor register. If AXI DMA is configured for an address space greater than 32, then also program the MSB 32 bits of the current descriptor.
2. Start the MM2S channel running by setting the run/stop bit to 1 (MM2S_DMACR.RS =1). The Halted bit (DMASR.Halted) should deassert indicating the MM2S channel is running.
3. If desired, enable interrupts by writing a 1 to MM2S_DMACR.IOC_IrqEn and MM2S_DMACR.Err_IrqEn.
4. Write a valid address to the Tail Descriptor register. If AXI DMA is configured for an address space greater than 32, then also program the MSB 32 bits of the tail descriptor.
5. Writing to the Tail Descriptor register triggers the DMA to start fetching the descriptors from the memory. In case of multichannel configuration, the fetching of descriptors starts when the packet arrives on the S2MM channel.
6. The fetched descriptors are processed, Data is read from the memory and then output to the MM2S streaming channel.

*/
        
/*********************************************************************/
/*                       define mmap locations                       */
/*          consult the README for the exact memory layout           */
/*********************************************************************/

#define	AXI_DMA_REGISTER_LOCATION          0xB0000000		//AXI DMA Register Address Map
#define	DESCRIPTOR_REGISTERS_SIZE          0x1000               //4K 
#define	SG_DMA_DESCRIPTORS_WIDTH           0x1000 //4KB - descriptor size                                                       
#define	MEMBLOCK_WIDTH                     0x4000 // 16K size of mem used by s2mm - the destination block size
#define	NUM_OF_DESCRIPTORS                 0x1		//number of descriptors for each direction
#define	HP0_S2MM_DMA_DESCRIPTORS_ADDRESS   0xB0020000
#define	HP0_S2MM_TARGET_MEM_ADDRESS        0xB0030000 //S2mm output goes to buffer located at this addr.

/*********************************************************************/
/*                   define all register locations                   */
/*               based on "LogiCORE IP Product Guide"                */
/*********************************************************************/
// S2MM CONTROL
#define S2MM_CONTROL_REGISTER       0x30    // S2MM_DMACR
#define S2MM_STATUS_REGISTER        0x34    // S2MM_DMASR
#define S2MM_CURDESC                0x38    // must align 0x40 addresses
#define S2MM_CURDESC_MSB            0x3C    // unused with 32bit addresses
#define S2MM_TAILDESC               0x40    // must align 0x40 addresses
#define S2MM_TAILDESC_MSB           0x44    // unused with 32bit addresses

struct SG_descriptor {
  unsigned int nextdesc;
  unsigned int nextdesc_msb;
  unsigned int buffer_address;
  unsigned int buffer_address_msb;
  unsigned int reserved_0;
  unsigned int reserved_1;
  unsigned int control;
  unsigned int status;
} SG_descr;


    int main() {

	unsigned int* axi_dma_register_mmap;
	unsigned int* s2mm_descriptor_register_mmap;
	unsigned int* dest_mem_map;
	int controlregister_ok = 0,s2mm_status;
	uint32_t s2mm_current_descriptor_address;
	uint32_t s2mm_tail_descriptor_address;


	int dh = open("/dev/mem", O_RDWR | O_SYNC); 
	axi_dma_register_mmap = mmap(NULL, DESCRIPTOR_REGISTERS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, dh, AXI_DMA_REGISTER_LOCATION);
	s2mm_descriptor_register_mmap= mmap(NULL, DESCRIPTOR_REGISTERS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, dh, HP0_S2MM_DMA_DESCRIPTORS_ADDRESS);
	dest_mem_map = mmap(NULL, MEMBLOCK_WIDTH * NUM_OF_DESCRIPTORS, PROT_READ | PROT_WRITE, MAP_SHARED, dh, (off_t)(HP0_S2MM_TARGET_MEM_ADDRESS));
	int i;
	
	/* // fill s2mm-register memory with zeros */
	/* for (i = 0; i < DESCRIPTOR_REGISTERS_SIZE; i++) { */
	/* 	char *p = (char *)s2mm_descriptor_register_mmap; */
	/* 	p[i] = 0x0; */
	/* } */

	//initializing the descriptor
	

	// fill target memory with zeros
        for (i = 0; i < (MEMBLOCK_WIDTH / 4) * NUM_OF_DESCRIPTORS; i++) {
		unsigned int *p = dest_mem_map;
		p[i] = 0x00000000;
	}
	

        
    	/*********************************************************************/
    	/*                 reset and halt all dma operations                 */
    	/*********************************************************************/
    	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] =  0x4; //WHY >>2? Bcs the array is of size unsigned int (4-byte) so we divide by 4 by shifting
    	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] =  0x0;

    	/*********************************************************************/
    	/*           build s2mm stream and control stream           */
    	/* chains will be filled with next desc, buffer width and registers  */
    	/*                         [0]: next descr                           */
    	/*                         [1]: reserved                             */
    	/*                         [2]: buffer addr                          */
    	/*********************************************************************/

	s2mm_current_descriptor_address = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS; // save current descriptor address

	s2mm_descriptor_register_mmap[0x0 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x40; // set next descriptor address
	s2mm_descriptor_register_mmap[0x8 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x0; // set target buffer address
	s2mm_descriptor_register_mmap[0x18 >> 2] = 16348; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x40 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x80; // set next descriptor address
	s2mm_descriptor_register_mmap[0x48 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x7D0000; // set target buffer address
	s2mm_descriptor_register_mmap[0x58 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x80 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0xC0; // set next descriptor address
	s2mm_descriptor_register_mmap[0x88 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0xFA0000; // set target buffer address
	s2mm_descriptor_register_mmap[0x98 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0xC0 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x100; // set next descriptor address
	s2mm_descriptor_register_mmap[0xC8 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x1770000; // set target buffer address
	s2mm_descriptor_register_mmap[0xD8 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x100 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x140; // set next descriptor address
	s2mm_descriptor_register_mmap[0x108 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x1F40000; // set target buffer address
	s2mm_descriptor_register_mmap[0x118 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x140 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x180; // set next descriptor address
	s2mm_descriptor_register_mmap[0x148 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x2710000; // set target buffer address
	s2mm_descriptor_register_mmap[0x158 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x180 >> 2] = 0x00; // set next descriptor address (unused?)
	s2mm_descriptor_register_mmap[0x188 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x2EE0000; // set target buffer address
	s2mm_descriptor_register_mmap[0x198 >> 2] = 0x47D0000; // set mm2s/s2mm buffer length to control register

	s2mm_tail_descriptor_address = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x180 ; // save tail descriptor address
    	/*********************************************************************/
    	/*                 set current descriptor addresses                  */
    	/*           and start dma operations (S2MM_DMACR.RS = 1)            */
    	/*********************************************************************/

    	axi_dma_register_mmap[S2MM_CURDESC>>2] =  s2mm_current_descriptor_address;
    	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] |= (0x1 << 4); //Enabling cyclic mode
	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] |= 0x1; //START

    	/*********************************************************************/
    	/*                          start transfer                           */
    	/*                 (by setting the taildescriptors)                  */
    	/*********************************************************************/

    	axi_dma_register_mmap[S2MM_TAILDESC>>2] =  s2mm_tail_descriptor_address;

    	/*********************************************************************/
    	/*                 wait until all transfers finished                 */
    	/*********************************************************************/

    	while (!controlregister_ok)
    {
    		s2mm_status = axi_dma_register_mmap[S2MM_STATUS_REGISTER >> 2];
    		controlregister_ok = ((s2mm_status & 0x00001000));
    	     	printf("Stream to memory-mapped status (0x%08x@0x%02x):\n", s2mm_status, S2MM_STATUS_REGISTER);
    		printf("S2MM_STATUS_REGISTER status register values:\n");
    		if (s2mm_status & 0x00000001) printf(" halted"); else printf(" running");
    		if (s2mm_status & 0x00000002) printf(" idle");
    		if (s2mm_status & 0x00000008) printf(" SGIncld");
    		if (s2mm_status & 0x00000010) printf(" DMAIntErr");
    		if (s2mm_status & 0x00000020) printf(" DMASlvErr");
    		if (s2mm_status & 0x00000040) printf(" DMADecErr");
    		if (s2mm_status & 0x00000100) printf(" SGIntErr");
    		if (s2mm_status & 0x00000200) printf(" SGSlvErr");
    		if (s2mm_status & 0x00000400) printf(" SGDecErr");
    		if (s2mm_status & 0x00001000) printf(" IOC_Irq");
    		if (s2mm_status & 0x00002000) printf(" Dly_Irq");
    		if (s2mm_status & 0x00004000) printf(" Err_Irq");
    		printf("\n");
    }
        

	return 0;
}
